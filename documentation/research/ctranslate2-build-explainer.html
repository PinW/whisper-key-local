<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Building CTranslate2 for Your GPU</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0d1117; color: #c9d1d9; line-height: 1.7; padding: 2rem; max-width: 860px; margin: 0 auto; }
  h1 { color: #58a6ff; font-size: 1.8rem; margin-bottom: 0.5rem; }
  h2 { color: #79c0ff; font-size: 1.3rem; margin-top: 2.5rem; margin-bottom: 0.8rem; padding-bottom: 0.3rem; border-bottom: 1px solid #21262d; }
  h3 { color: #d2a8ff; font-size: 1.1rem; margin-top: 1.5rem; margin-bottom: 0.5rem; }
  p { margin-bottom: 1rem; }
  .subtitle { color: #8b949e; font-size: 0.95rem; margin-bottom: 2rem; }
  .diagram { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 1.5rem; margin: 1.2rem 0; font-family: 'Consolas', 'Fira Code', monospace; font-size: 0.85rem; line-height: 1.8; overflow-x: auto; }
  .step { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 1.2rem 1.5rem; margin: 1rem 0; }
  .step-number { display: inline-block; background: #1f6feb; color: #fff; width: 28px; height: 28px; border-radius: 50%; text-align: center; line-height: 28px; font-weight: bold; font-size: 0.85rem; margin-right: 0.5rem; }
  .highlight { color: #ffa657; }
  .good { color: #3fb950; }
  .bad { color: #f85149; }
  .neutral { color: #8b949e; }
  .keyword { color: #ff7b72; }
  .analogy { background: #1c2333; border-left: 3px solid #58a6ff; padding: 1rem 1.2rem; margin: 1rem 0; border-radius: 0 6px 6px 0; }
  .warning { background: #2a1f0d; border-left: 3px solid #d29922; padding: 1rem 1.2rem; margin: 1rem 0; border-radius: 0 6px 6px 0; }
  .tldr { background: #0f2d1a; border-left: 3px solid #3fb950; padding: 1rem 1.2rem; margin: 1rem 0; border-radius: 0 6px 6px 0; }
  ul { margin: 0.5rem 0 1rem 1.5rem; }
  li { margin-bottom: 0.4rem; }
  code { background: #1f2937; padding: 0.15rem 0.4rem; border-radius: 4px; font-family: 'Consolas', monospace; font-size: 0.9em; color: #ffa657; }
  .arrow { color: #484f58; }
  .flow { display: flex; align-items: center; flex-wrap: wrap; gap: 0.3rem; margin: 0.5rem 0; }
  .flow-box { background: #21262d; border: 1px solid #30363d; padding: 0.3rem 0.7rem; border-radius: 4px; font-size: 0.85rem; }
  .flow-box.ours { border-color: #3fb950; color: #3fb950; }
  .flow-box.problem { border-color: #f85149; color: #f85149; }
</style>
</head>
<body>

<h1>Building CTranslate2 for Your GPU</h1>
<p class="subtitle">Why the pre-built wheel doesn't work, and what building from source actually means</p>

<h2>The situation</h2>

<p>CTranslate2 just added AMD GPU support in version 4.7.0. They released pre-built wheels (ready-to-install packages). But those wheels were built for a specific setup:</p>

<div class="diagram">
  <span class="neutral">Pre-built wheel targets:</span>
  <br>ROCm version: <span class="bad">7.1.1</span> &nbsp; (we have <span class="good">6.2</span>)
  <br>GPU architectures: <span class="bad">gfx1030, gfx1100, gfx1101, ...</span> &nbsp; (we need <span class="good">gfx1010</span>)
</div>

<p>When you <code>pip install</code> a wheel, you're installing <em>pre-compiled</em> code. It was already translated from human-readable source code into machine instructions — machine instructions that target specific hardware and specific library versions. You can't change those after the fact.</p>

<div class="analogy">
  <strong>Think of it like this:</strong> A pre-built wheel is like a pre-assembled IKEA shelf built for a specific wall size. If your wall is different, you can't just force it to fit — you need to go back to the raw materials and build it for your wall.
</div>

<h2>What "building from source" means</h2>

<p>Building from source means downloading the human-readable code and running it through a compiler on <em>your</em> machine, so it produces machine instructions that match <em>your</em> specific setup.</p>

<div class="diagram">
  <span class="highlight">Source code</span> (C++, same for everyone)
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="arrow">│</span>
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="arrow">▼</span>
  <br><span class="highlight">Compiler</span> (reads your local SDK headers to know what functions exist)
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="arrow">│</span>
  <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="arrow">▼</span>
  <br><span class="good">Your wheel</span> (compiled for ROCm 6.2 + gfx1010)
</div>

<p>The compiler looks at the ROCm SDK installed on your machine to understand what functions are available. Since you have ROCm 6.2, it'll use ROCm 6.2's function definitions. The resulting binary will call the right functions for your system.</p>

<h2>The build process, step by step</h2>

<div class="step">
  <p><span class="step-number">1</span> <strong>Get the source code</strong></p>
  <p>Clone the CTranslate2 repo at tag v4.7.1. This gives us the exact code that the pre-built wheel was made from — just not compiled yet.</p>
</div>

<div class="step">
  <p><span class="step-number">2</span> <strong>Check that ROCm 6.2 SDK has everything we need</strong></p>
  <p>CTranslate2 uses several ROCm libraries. The build system (CMake) will look for their header files and compiled libraries on your machine:</p>
  <ul>
    <li><code>hipblas</code> — math operations (matrix multiplication)</li>
    <li><code>hiprand</code> — random number generation on GPU</li>
    <li><code>rocprim</code> — basic parallel building blocks</li>
    <li><code>rocthrust</code> — higher-level parallel algorithms</li>
    <li><code>hipcub</code> — GPU utility functions</li>
  </ul>
  <p>These should all be part of the HIP SDK 6.2 install. We just need to verify they're there — it's a quick file check.</p>
</div>

<div class="step">
  <p><span class="step-number">3</span> <strong>Build oneDNN (optional, for CPU performance)</strong></p>
  <p>oneDNN is Intel's library for optimized CPU math. CTranslate2 uses it for the CPU fallback path. We have two choices:</p>
  <ul>
    <li><strong>Build it</strong> — better CPU performance when GPU isn't used</li>
    <li><strong>Skip it</strong> (<code>WITH_DNNL=OFF</code>) — simpler build, GPU path unaffected, CPU path slower</li>
  </ul>
  <p>Since our whole goal is GPU acceleration, skipping it is reasonable for a first attempt.</p>
</div>

<div class="step">
  <p><span class="step-number">4</span> <strong>Configure with CMake</strong></p>
  <p>CMake is a build configuration tool. We tell it what we want:</p>
  <div class="diagram">
    cmake
    <br>&nbsp;&nbsp;-DWITH_HIP=ON &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="neutral"># enable AMD GPU support</span>
    <br>&nbsp;&nbsp;-DCMAKE_HIP_ARCHITECTURES=gfx1010 &nbsp;<span class="neutral"># compile GPU code for our card</span>
    <br>&nbsp;&nbsp;-DWITH_DNNL=OFF &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="neutral"># skip Intel CPU library (optional)</span>
  </div>
  <p>CMake reads the source code's build instructions (<code>CMakeLists.txt</code>), finds the ROCm SDK on your machine, and generates the actual build files.</p>
  <p><strong>This is where we'd discover ROCm 6 vs 7 problems.</strong> If the source code calls a function that only exists in ROCm 7, the compiler will say <em>"I can't find this function"</em> — and we'd know exactly what to fix.</p>
</div>

<div class="step">
  <p><span class="step-number">5</span> <strong>Compile</strong></p>
  <p>The actual build. The compiler (clang, which ships with the ROCm SDK) reads all the C++ source files and produces:</p>
  <ul>
    <li><code>ctranslate2.dll</code> — the main library, with GPU code compiled for gfx1010</li>
    <li><code>_ext.pyd</code> — the Python binding</li>
  </ul>
  <p>This is the slow part — could take 10-30 minutes depending on your CPU.</p>
</div>

<div class="step">
  <p><span class="step-number">6</span> <strong>Package as a wheel</strong></p>
  <p>Take the compiled files and package them into a <code>.whl</code> file that <code>pip install</code> can use. Then install it and test.</p>
</div>

<h2>What could go wrong</h2>

<h3>Likely fine</h3>
<ul>
  <li><strong>gfx1010 as a compiler target</strong> — the LLVM compiler inside ROCm 6.2 almost certainly knows how to generate code for gfx1010. GPU architecture targets are an LLVM thing, not an AMD "supported GPUs" thing.</li>
  <li><strong>ROCm 6.2 SDK packages</strong> — a full HIP SDK install should include everything CMake needs.</li>
</ul>

<h3>Might need small fixes</h3>
<ul>
  <li><strong>ROCm 7 API calls in the source</strong> — the CTranslate2 code was written for ROCm 7. Some function calls might not exist in ROCm 6.2 headers. The compiler would tell us exactly which ones, and we'd replace them with the ROCm 6 equivalents. Likely a handful of lines at most.</li>
</ul>

<h3>Unknown</h3>
<ul>
  <li><strong>Runtime behavior on gfx1010</strong> — even if it compiles perfectly, the GPU code has never been tested on gfx1010 (by anyone, ever). There could be subtle differences in how gfx1010 handles certain operations. This is the "we're in uncharted territory" risk — same risk we've had this entire project.</li>
</ul>

<h2>Why this solves our problem</h2>

<p>The pre-built wheel had four possible failure layers:</p>

<div class="diagram">
  <span class="bad">1. HIP runtime shim</span> (amdhip64_6 pretending to be 7)
  <br><span class="bad">2. hipBLAS API mismatch</span> (compiled for v7 headers, running on v6)
  <br><span class="bad">3. Tensile kernel coverage</span> (community kernels may lack some GEMM shapes)
  <br><span class="bad">4. Pre-compiled GPU code</span> (HIP kernels targeting gfx1030+, not gfx1010)
</div>

<p>Building from source eliminates layers 1, 2, and 4 completely:</p>

<div class="diagram">
  <span class="good">1. No shim needed</span> — compiled against ROCm 6.2 directly, links to amdhip64_6.dll
  <br><span class="good">2. No API mismatch</span> — compiled against ROCm 6.2 headers, calls ROCm 6.2 functions
  <br><span class="bad">3. Tensile kernels</span> — still depends on community rocBLAS (unchanged)
  <br><span class="good">4. GPU code targets gfx1010</span> — compiled specifically for our architecture
</div>

<p>Layer 3 (Tensile kernels) is the one thing building from source doesn't fix — that's the community rocBLAS we already installed. But our earlier 2x2 matmul test proved that basic GEMM works through those kernels. If the build eliminates the other three layers and we still get errors, then we'll know for sure it's a Tensile kernel coverage issue.</p>

<div class="tldr">
  <strong>Bottom line:</strong> Building from source is the cleanest path forward. It eliminates most of the unknowns in one shot, and if something fails during compilation, the error messages will tell us exactly what to fix — unlike the opaque <code>CUBLAS_STATUS_INVALID_VALUE</code> we've been staring at.
</div>

</body>
</html>
